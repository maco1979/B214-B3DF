#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CVE漏洞信息处理器
功能：
1. 解析deltaLog.json文件，提取漏洞基本信息
2. 通过githubLink获取完整的CVE JSON文件
3. 解析CVE JSON文件，提取关键漏洞信息
4. 将漏洞信息整合到结构化文件中
"""

import json
import requests
import time
import os
import logging
from typing import List, Dict, Any, Optional

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('cve_processor.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class CVEProcessor:
    """CVE漏洞信息处理器类"""
    
    def __init__(self, delta_log_path: str, output_dir: str = "./cve_data"):
        """
        初始化CVE处理器
        
        Args:
            delta_log_path: deltaLog.json文件路径
            output_dir: 输出目录，用于保存处理后的数据
        """
        self.delta_log_path = delta_log_path
        self.output_dir = output_dir
        self.cve_data_dir = os.path.join(output_dir, "raw_cve_data")
        
        # 创建输出目录
        os.makedirs(self.output_dir, exist_ok=True)
        os.makedirs(self.cve_data_dir, exist_ok=True)
    
    def parse_delta_log(self) -> List[Dict[str, Any]]:
        """
        解析deltaLog.json文件，提取所有漏洞信息
        
        Returns:
            包含所有漏洞基本信息的列表
        """
        logger.info(f"开始解析deltaLog.json文件: {self.delta_log_path}")
        
        try:
            with open(self.delta_log_path, 'r', encoding='utf-8') as f:
                delta_log = json.load(f)
            
            all_vulnerabilities = []
            for fetch_record in delta_log:
                # 合并新增和更新的漏洞
                new_vulns = fetch_record.get('new', [])
                updated_vulns = fetch_record.get('updated', [])
                
                all_vulnerabilities.extend(new_vulns)
                all_vulnerabilities.extend(updated_vulns)
            
            # 去重，确保每个CVE只处理一次
            unique_vulns = {}
            for vuln in all_vulnerabilities:
                unique_vulns[vuln['cveId']] = vuln
            
            unique_vuln_list = list(unique_vulns.values())
            logger.info(f"解析完成，共提取 {len(unique_vuln_list)} 个唯一漏洞")
            
            return unique_vuln_list
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON解析错误: {e}")
            raise
        except Exception as e:
            logger.error(f"解析deltaLog.json文件失败: {e}")
            raise
    
    def fetch_cve_json(self, github_link: str, cve_id: str) -> Optional[Dict[str, Any]]:
        """
        通过githubLink获取完整的CVE JSON文件
        
        Args:
            github_link: CVE JSON文件的GitHub链接
            cve_id: CVE编号
            
        Returns:
            CVE JSON数据，如果获取失败则返回None
        """
        logger.info(f"正在获取CVE JSON文件: {cve_id}")
        
        # 本地保存路径
        local_file_path = os.path.join(self.cve_data_dir, f"{cve_id}.json")
        
        # 检查本地是否已存在，避免重复下载
        if os.path.exists(local_file_path):
            logger.info(f"本地已存在CVE JSON文件，直接读取: {cve_id}")
            try:
                with open(local_file_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"读取本地CVE JSON文件失败: {e}")
                # 读取失败，删除本地文件并重新下载
                os.remove(local_file_path)
        
        # 发送HTTP请求获取CVE JSON文件
        try:
            response = requests.get(github_link, timeout=15)
            response.raise_for_status()
            
            cve_json = response.json()
            
            # 保存到本地
            with open(local_file_path, 'w', encoding='utf-8') as f:
                json.dump(cve_json, f, ensure_ascii=False, indent=2)
            
            logger.info(f"成功获取并保存CVE JSON文件: {cve_id}")
            
            # 添加延迟，避免请求过于频繁
            time.sleep(1)
            
            return cve_json
            
        except requests.exceptions.RequestException as e:
            logger.error(f"获取CVE JSON文件失败 {cve_id}: {e}")
            return None
        except json.JSONDecodeError as e:
            logger.error(f"解析CVE JSON文件失败 {cve_id}: {e}")
            return None
        except Exception as e:
            logger.error(f"处理CVE JSON文件失败 {cve_id}: {e}")
            return None
    
    def extract_key_info(self, cve_json: Dict[str, Any], basic_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        从CVE JSON文件中提取关键漏洞信息
        
        Args:
            cve_json: CVE JSON数据
            basic_info: 漏洞基本信息
            
        Returns:
            包含关键漏洞信息的字典
        """
        # 初始化结果字典
        key_info = {
            **basic_info,
            'cveMetadata': {},
            'descriptions': [],
            'affectedProducts': [],
            'cvssScores': [],
            'references': [],
            'remediations': [],
            'workarounds': []
        }
        
        try:
            # 验证dataType和dataVersion
            if cve_json.get('dataType') != 'CVE_RECORD':
                logger.warning(f"无效的dataType: {cve_json.get('dataType')}, 预期为CVE_RECORD")
                # 可以选择抛出异常或继续处理，这里选择继续处理但记录警告
            
            # 验证dataVersion，确保兼容性
            data_version = cve_json.get('dataVersion')
            if data_version != '5.2':
                logger.warning(f"dataVersion为{data_version}，当前只验证5.2版本，可能存在兼容性问题")
            
            # 提取cveMetadata
            if 'cveMetadata' in cve_json:
                key_info['cveMetadata'] = cve_json['cveMetadata']
            
            # 获取containers.cna部分
            cna = cve_json.get('containers', {}).get('cna', {})
            
            # 提取漏洞描述
            if 'descriptions' in cna:
                key_info['descriptions'] = cna['descriptions']
            
            # 提取受影响产品
            if 'affected' in cna:
                key_info['affectedProducts'] = cna['affected']
            
            # 提取CVSS评分
            if 'metrics' in cna:
                metrics_data = cna['metrics']
                # 处理metrics是列表的情况
                if isinstance(metrics_data, list):
                    for metric in metrics_data:
                        for metric_type, metric_values in metric.items():
                            if isinstance(metric_values, list):
                                for metric_value in metric_values:
                                    key_info['cvssScores'].append({
                                        'type': metric_type,
                                        'score': metric_value.get('cvssV3_1', {}).get('baseScore'),
                                        'vectorString': metric_value.get('cvssV3_1', {}).get('vectorString'),
                                        'severity': metric_value.get('cvssV3_1', {}).get('baseSeverity')
                                    })
                # 处理metrics是字典的情况
                elif isinstance(metrics_data, dict):
                    for metric_type, metrics in metrics_data.items():
                        if isinstance(metrics, list):
                            for metric in metrics:
                                key_info['cvssScores'].append({
                                    'type': metric_type,
                                    'score': metric.get('cvssV3_1', {}).get('baseScore'),
                                    'vectorString': metric.get('cvssV3_1', {}).get('vectorString'),
                                    'severity': metric.get('cvssV3_1', {}).get('baseSeverity')
                                })
            
            # 提取参考链接
            if 'references' in cna:
                key_info['references'] = cna['references']
            
            # 提取修复建议
            if 'remediations' in cna:
                key_info['remediations'] = cna['remediations']
            
            # 提取临时解决方案
            if 'workarounds' in cna:
                key_info['workarounds'] = cna['workarounds']
            
        except Exception as e:
            logger.error(f"提取关键信息失败 {basic_info.get('cveId', '未知')}: {e}")
        
        return key_info
    
    def process_all_vulnerabilities(self) -> List[Dict[str, Any]]:
        """
        处理所有漏洞，包括获取JSON文件和提取关键信息
        
        Returns:
            包含所有漏洞完整信息的列表
        """
        # 解析deltaLog.json
        vulnerabilities = self.parse_delta_log()
        
        processed_vulns = []
        failed_count = 0
        
        for i, vuln in enumerate(vulnerabilities):
            cve_id = vuln['cveId']
            github_link = vuln['githubLink']
            
            logger.info(f"处理漏洞 {i+1}/{len(vulnerabilities)}: {cve_id}")
            
            # 获取CVE JSON文件
            cve_json = self.fetch_cve_json(github_link, cve_id)
            
            if cve_json:
                # 提取关键信息
                full_info = self.extract_key_info(cve_json, vuln)
                processed_vulns.append(full_info)
            else:
                failed_count += 1
                logger.warning(f"漏洞处理失败: {cve_id}")
        
        logger.info(f"所有漏洞处理完成，成功: {len(processed_vulns)}, 失败: {failed_count}")
        
        return processed_vulns
    
    def save_processed_data(self, processed_vulns: List[Dict[str, Any]]):
        """
        保存处理后的漏洞信息
        
        Args:
            processed_vulns: 包含所有漏洞完整信息的列表
        """
        # 保存完整处理结果
        full_output_path = os.path.join(self.output_dir, "processed_cve_data.json")
        with open(full_output_path, 'w', encoding='utf-8') as f:
            json.dump(processed_vulns, f, ensure_ascii=False, indent=2)
        
        logger.info(f"完整处理结果已保存到: {full_output_path}")
        
        # 保存简化版结果，方便导入到漏洞管理系统
        simplified_vulns = []
        for vuln in processed_vulns:
            simplified = {
                'cveId': vuln['cveId'],
                'cveOrgLink': vuln['cveOrgLink'],
                'githubLink': vuln['githubLink'],
                'dateUpdated': vuln['dateUpdated'],
                'state': vuln['cveMetadata'].get('state', ''),
                'published': vuln['cveMetadata'].get('datePublished', ''),
                'descriptions': [desc['value'] for desc in vuln['descriptions'] if desc['lang'] == 'en'],
                'cvssScores': vuln['cvssScores'],
                'affectedProducts': vuln['affectedProducts'],
                'references': [ref['url'] for ref in vuln['references']],
                'hasRemediation': len(vuln['remediations']) > 0
            }
            simplified_vulns.append(simplified)
        
        simplified_output_path = os.path.join(self.output_dir, "simplified_cve_data.json")
        with open(simplified_output_path, 'w', encoding='utf-8') as f:
            json.dump(simplified_vulns, f, ensure_ascii=False, indent=2)
        
        logger.info(f"简化版结果已保存到: {simplified_output_path}")
        
        # 保存统计信息
        stats = {
            'totalVulnerabilities': len(processed_vulns),
            'withCvssScores': len([v for v in processed_vulns if v['cvssScores']]),
            'withRemediations': len([v for v in processed_vulns if v['remediations']]),
            'withWorkarounds': len([v for v in processed_vulns if v['workarounds']]),
            'processingTime': time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        }
        
        stats_output_path = os.path.join(self.output_dir, "cve_processing_stats.json")
        with open(stats_output_path, 'w', encoding='utf-8') as f:
            json.dump(stats, f, ensure_ascii=False, indent=2)
        
        logger.info(f"统计信息已保存到: {stats_output_path}")
        
        return {
            'fullOutputPath': full_output_path,
            'simplifiedOutputPath': simplified_output_path,
            'statsOutputPath': stats_output_path
        }
    
    def run(self):
        """
        执行完整的处理流程
        """
        logger.info("开始执行CVE漏洞信息处理流程")
        start_time = time.time()
        
        try:
            # 解析deltaLog.json
            vulnerabilities = self.parse_delta_log()
            
            # 处理所有漏洞
            processed_vulns = self.process_all_vulnerabilities()
            
            # 保存处理结果
            output_paths = self.save_processed_data(processed_vulns)
            
            end_time = time.time()
            duration = end_time - start_time
            
            logger.info(f"CVE漏洞信息处理流程完成，耗时: {duration:.2f} 秒")
            logger.info(f"处理结果文件:")
            for name, path in output_paths.items():
                logger.info(f"  {name}: {path}")
            
            return output_paths
            
        except Exception as e:
            logger.error(f"CVE漏洞信息处理流程失败: {e}")
            raise

def main():
    """主函数"""
    # 配置deltaLog.json文件路径
    delta_log_path = r"c:\Users\42235\AppData\Local\Temp\576d0162-98f7-48ef-a605-e03a76c8242d_cvelistV5-main.zip.cvelistV5-main.zip\cvelistV5-main\cves\deltaLog.json"
    
    # 创建CVE处理器实例
    processor = CVEProcessor(delta_log_path)
    
    # 执行处理流程
    processor.run()

if __name__ == "__main__":
    main()
